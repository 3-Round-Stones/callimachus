# 
#    Portions Copyright (c) 2009-10 Zepheira LLC, Some Rights Reserved
#    Portions Copyright (c) 2010-11 Talis Inc, Some Rights Reserved
# 
#    Licensed under the Apache License, Version 2.0 (the "License");
#    you may not use this file except in compliance with the License.
#    You may obtain a copy of the License at
# 
#        http://www.apache.org/licenses/LICENSE-2.0
# 
#    Unless required by applicable law or agreed to in writing, software
#    distributed under the License is distributed on an "AS IS" BASIS,
#    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#    See the License for the specific language governing permissions and
#    limitations under the License.

@prefix xsd:<http://www.w3.org/2001/XMLSchema#>.
@prefix rdf:<http://www.w3.org/1999/02/22-rdf-syntax-ns#>.
@prefix rdfs:<http://www.w3.org/2000/01/rdf-schema#>.
@prefix owl:<http://www.w3.org/2002/07/owl#>.
@prefix msg:<http://www.openrdf.org/rdf/2011/messaging#>.
@prefix calli:<http://callimachusproject.org/rdf/2009/framework#>.
@prefix :<#>.

<> a <../SchemaGraph>.

################################
# GET describedby
################################

:GetDescription rdfs:subClassOf msg:Message;
    rdfs:subClassOf [owl:onProperty msg:target; owl:allValuesFrom <../Serviceable>];
    rdfs:subClassOf [owl:onProperty msg:object; owl:allValuesFrom <java:org.openrdf.query.GraphQueryResult>];
    calli:title "RDF Describe";
    calli:rel "describedby";
    calli:method "GET";
    calli:query "describe";
    calli:type "application/rdf+xml;q=0.4", "text/turtle;q=0.5";
    calli:transform :TransformDescription;
    calli:script """
        var queue = [];
        queue.push(this.resource);
        var con = this.objectConnection;
        var base = this.resource.stringValue();
        var baseIsHash = base.charAt(base.length - 1) == '#';
        var stmts = con.getStatements(null, org.openrdf.model.vocabulary.RDFS.ISDEFINEDBY, this.resource, false, []);
        try {
            while (stmts.hasNext()) {
                queue.push(stmts.next().subject);
            }
        } finally {
            stmts.close();
        }
        return new org.openrdf.query.GraphQueryResult({
            close: function() {
                stmts.close();
            },
            getNamespaces: function() {
                var namespaces = con.getNamespaces();
                var map = new java.util.HashMap();
                while (namespaces.hasNext()) {
                    var ns = namespaces.next();
                    map.put(ns.getPrefix(), ns.getName());
                }
                return map;
            },
            hasNext: function() {
                while (!stmts.hasNext() && queue.length > 0) {
                    stmts.close();
                    stmts = con.getStatements(queue.shift(), null, null, false, []);
                }
                return stmts.hasNext();
            },
            next: function() {
                while (!stmts.hasNext() && queue.length > 0) {
                    stmts.close();
                    stmts = con.getStatements(queue.shift(), null, null, false, []);
                }
                var st = stmts.next();
                var uri = st.object.stringValue()
                if (st.object instanceof org.openrdf.model.URI) {
                    if (uri.length > base.length && uri.indexOf(base) == 0) {
                        var chr = uri.charAt(base.length);
                        if (baseIsHash || chr == '#') {
                            queue.push(st.object);
                        }
                    }
                } else if (st.object instanceof org.openrdf.model.Resource) {
                    queue.push(st.object);
                }
                return st;
            },
            remove: function() {
                stmts.remove();
            },
        });
    """.

:TransformDescription rdfs:subClassOf msg:Message;
    rdfs:subClassOf [owl:onProperty msg:target; owl:allValuesFrom <../Serviceable>];
    rdfs:subClassOf [owl:onProperty msg:object; owl:allValuesFrom <java:java.io.InputStream>];
    calli:type "application/xhtml+xml";
    calli:transform <../transforms/TransformLayout>;
    calli:xslt <describe.xsl>.

:inputStream a owl:ObjectProperty, owl:FunctionalProperty;
    rdfs:domain :TransformDescription;
    rdfs:range <java:java.io.InputStream>;
    calli:type "application/rdf+xml".

################################
# POST INSERT DATA
################################

:PostInsertData rdfs:subClassOf msg:Message;
    rdfs:subClassOf [owl:onProperty msg:target; owl:allValuesFrom <../Composite>];
    rdfs:subClassOf [owl:onProperty msg:object; owl:allValuesFrom <../Serviceable>];
    calli:method "POST";
    calli:query "describe";
    calli:realm </>;
    calli:expect "201-created";
    calli:type "text/plain";
    calli:imports <java:org.openrdf.annotations.Iri>;
    calli:imports <java:org.openrdf.query.QueryLanguage>;
    calli:imports <java:org.callimachusproject.form.helpers.TripleAnalyzer>;
    calli:imports <java:org.callimachusproject.server.exceptions.BadRequest>;
    calli:imports <java:org.callimachusproject.server.exceptions.Forbidden>;
    calli:imports <java:org.callimachusproject.server.exceptions.Conflict>;
    calli:imports <java:org.callimachusproject.server.exceptions.InternalServerError>;
    calli:imports <../Creatable>;
    calli:imports <../Editable>;
    calli:script """
        var con = this.objectConnection;
        var vf = con.valueFactory;
        var of = con.objectFactory;

        //# Parse INSERT DATA
        var analyzer = new TripleAnalyzer();
        var string = analyzer.parseInsertData(insertData, this.toString());
        
        //# Verify input
        if (analyzer.isEmpty())
            throw new BadRequest("Missing data");
        if (!analyzer.isSingleton())
            throw new BadRequest("Only one entity can be inserted per request");
        if (analyzer.isDisconnectedNodePresent())
            throw new BadRequest("Blank nodes must be connected");
        var location = analyzer.subject;
        if (location.toString().indexOf(this.toString()) != 0)
            throw new BadRequest("Resource URI must start with: " + this);
        var local = location.toString().substring(this.toString().length);
        if (local.indexOf('/') == 0 && this.toString().lastIndexOf('/') != this.toString().length - 1) {
            local = local.substring(1);
        }
        if (local.lastIndexOf('/') == local.length - 1) {
            local = local.substring(0, local.length -1);
        }
        if (local.indexOf('/') >= 0)
            throw new BadRequest("Can only created nested components here");
        var newCopy = of.createObject(location, analyzer.getTypes(location));
        if (this.calliHasComponent.contains(newCopy))
            throw new Conflict("Resource already exists");
        if (!(newCopy instanceof Editable))
            throw new BadRequest("Resource is not Editable");

        //# Execute input
        var update = con.prepareUpdate(QueryLanguage.SPARQL, string, this.toString());
        update.setBinding("this", this.resource);
        update.execute();

        var iter = this.FindCreator(newCopy).iterator();
        if (!iter.hasNext())
            throw new InternalServerError("Could not find user");
        while (iter.hasNext()) {
            var user = iter.next();
            function findConcepts(klass, visited, callback) {
                if (visited.contains(klass))
                    return true;
                visited.add(klass);
                if (klass.isAnnotationPresent(Iri)) {
                    callback(klass.getAnnotation(Iri).value());
                }
                var sup = klass.getSuperclass();
                if (sup) {
                    findConcepts(sup, visited, callback);
                }
                var interfaces = klass.getInterfaces();
                for (var i = 0; i < interfaces.length; i++) {
                    findConcepts(interfaces[i], visited, callback);
                }
                return false;
            }
            var creatable = false;
            findConcepts(newCopy.getClass(), new java.util.HashSet(), function(type) {
                var cls = con.getObject(type);
                if (cls instanceof Creatable) {
                    creatable = true;
                    if (!cls.calliIsAuthorized(user, "POST", "create"))
                        throw new Forbidden("You are not permitted to create " + cls + " resources");
                }
            });
            if (!creatable)
                throw new Forbidden("You are not permitted to create this type of resource");
        }

        //# Add permissions and component membership
        newCopy.calliEditor.addAll(this.FindContributor(newCopy));
        newCopy.calliReader.addAll(this.SelectAllReaders());
        newCopy.calliEditor.addAll(this.SelectAllEditors());
        newCopy.calliAdministrator.addAll(this.SelectAllAdministrators());
        this.calliHasComponent.add(newCopy);
        var iter = analyzer.getResources().iterator();
        while (iter.hasNext()) {
            var partner = iter.next();
            if (!partner.toString().equals(this.toString())) {
                con.getObject(partner).touchRevision(); // FIXME this shouldn't be needed
            }
        }
        return newCopy;
    """.

:insertData a owl:FunctionalProperty, owl:ObjectProperty;
    rdfs:domain :PostInsertData;
    rdfs:range <java:java.io.InputStream>;
    calli:type "application/sparql-update".

################################
# PATCH DELETE INSERT
################################

:PatchDeleteInsert rdfs:subClassOf msg:Message;
    rdfs:subClassOf [owl:onProperty msg:target; owl:allValuesFrom <../Serviceable>];
    rdfs:subClassOf [owl:onProperty msg:object; owl:allValuesFrom owl:Nothing];
    calli:method "PATCH";
    calli:query "describe";
    calli:realm </>;
    calli:imports <java:org.openrdf.query.QueryLanguage>;
    calli:imports <java:org.callimachusproject.form.helpers.TripleAnalyzer>;
    calli:imports <java:org.callimachusproject.server.exceptions.BadRequest>;
    calli:imports <java:org.callimachusproject.server.exceptions.Forbidden>;
    calli:imports <java:org.callimachusproject.server.exceptions.Conflict>;
    calli:imports <../Serviceable>;
    calli:script """
        var con = this.objectConnection;

        //# Parse DELETE INSERT
        var analyzer = new TripleAnalyzer();
        var string = analyzer.parseUpdate(deleteInsert, this.toString());
        
        //# Verify input
        if (analyzer.isEmpty())
            throw new BadRequest("Missing data");
        if (!analyzer.isAbout(this.resource))
            throw new BadRequest("Can only delete or insert triples of the entity: " + this.toString());
        if (!analyzer.getTypes(this.resource).isEmpty())
            throw new BadRequest("Cannot change entity type");
        if (analyzer.isDisconnectedNodePresent())
            throw new BadRequest("Blank nodes must be connected");
        //# FIXME possible security hole if hash or blank resources are added with a restricted type

        //# Evaluate input
        var update = con.prepareUpdate(QueryLanguage.SPARQL, string, this.toString());
        update.setBinding("this", this.resource);
        update.execute();

        this.touchRevision();
        //# FIXME we shouldn't need to touch anything
        var parent = this.SelectParentComposite();
        if (parent) {
            parent.touchRevision();
        }
    """.

:deleteInsert a owl:FunctionalProperty, owl:ObjectProperty;
    rdfs:domain :PatchDeleteInsert;
    rdfs:range <java:java.io.InputStream>;
    calli:type "application/sparql-update".

